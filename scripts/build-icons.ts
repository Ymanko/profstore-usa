/* eslint-disable no-console */
import { glob } from 'glob';
import { parse } from 'node-html-parser';
import { promises as fs } from 'node:fs';
import * as path from 'node:path';

const cwd = process.cwd();
const inputDir = path.join(cwd, 'public', 'icons');
const inputDirRelative = path.relative(cwd, inputDir);
const outputFile = path.join(cwd, 'public', 'sprites.svg');
const outputFileRelative = path.relative(cwd, outputFile);
const typesOutputFile = path.join(cwd, 'src', 'shared', 'types', 'icon-names.ts');
const typesOutputFileRelative = path.relative(cwd, typesOutputFile);

async function main() {
  const files = glob
    .sync('**/*.svg', {
      cwd: inputDir,
    })
    .sort((a, b) => a.localeCompare(b));

  if (files.length === 0) {
    console.log(`‚ùå No SVG files found in ${inputDirRelative}`);
    process.exit(0);
  }

  console.log(`‚ú® Found ${files.length} SVG files in ${inputDirRelative}`);

  const spritesheetContent = await generateSvgSprite({
    files,
    inputDir,
  });

  await writeIfChanged(outputFile, spritesheetContent);
  console.log(`‚úÖ Generated sprite: ${outputFileRelative}`);

  const iconNames = files.map(file => file.replace(/\.svg$/, ''));
  const typesContent = generateTypes({ names: iconNames });

  await writeIfChanged(typesOutputFile, typesContent);
  console.log(`‚úÖ Generated types: ${typesOutputFileRelative}`);

  console.log(`\nüéâ Done! Generated ${files.length} icons.`);
}

async function generateSvgSprite({ files, inputDir }: { files: string[]; inputDir: string }) {
  const symbols = await Promise.all(
    files.map(async file => {
      const input = await fs.readFile(path.join(inputDir, file), 'utf8');
      const root = parse(input);

      const svg = root.querySelector('svg');
      if (!svg) throw new Error(`No SVG element found in ${file}`);

      svg.tagName = 'symbol';
      svg.setAttribute('id', file.replace(/\.svg$/, ''));

      svg.removeAttribute('xmlns');
      svg.removeAttribute('xmlns:xlink');
      svg.removeAttribute('version');
      svg.removeAttribute('width');
      svg.removeAttribute('height');

      // Get the symbol as string and format it
      const symbolString = svg.toString();

      // Clean up and format
      const formatted = symbolString
        .replace(/\n/g, ' ') // Remove all newlines first
        .replace(/\s+/g, ' ') // Replace multiple spaces with single space
        .replace(/\s*>\s*/g, '>') // Remove spaces around >
        .replace(/\s*<\s*/g, '<') // Remove spaces around <
        .replace(/>\s+</g, '>\n<') // Add newlines between tags
        .split('\n')
        .map((line, index, array) => {
          const trimmed = line.trim();
          if (index === 0) return `    ${trimmed}`; // Opening symbol tag
          if (index === array.length - 1) return `    ${trimmed}`; // Closing symbol tag
          return `      ${trimmed}`; // Inner content
        })
        .join('\n');

      return formatted;
    }),
  );

  return [
    `<svg xmlns="http://www.w3.org/2000/svg" width="0" height="0">`,
    `  <defs>`,
    ...symbols,
    `  </defs>`,
    `</svg>`,
  ].join('\n');
}

function generateTypes({ names }: { names: string[] }) {
  return [
    `// This file is generated by npm run build:icons`,
    `// Do not edit manually`,
    ``,
    `export type IconName =`,
    ...names.map(name => `  | '${name}'`),
    ``,
  ].join('\n');
}

async function writeIfChanged(filepath: string, newContent: string) {
  try {
    const currentContent = await fs.readFile(filepath, 'utf8');
    if (currentContent === newContent) {
      return;
    }
  } catch (_error) {}

  await fs.writeFile(filepath, newContent, 'utf8');
}

main().catch(error => {
  console.error('‚ùå Error:', error);
  process.exit(1);
});
